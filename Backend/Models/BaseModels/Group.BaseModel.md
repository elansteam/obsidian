## `id: int`
> [!info] ID группы #UniqueIndex #Autoincrement 

## `name: str`
> [!info] Отображаемое имя группы

## `domain: str | None`
> [!info]  Доменное имя группы #UniqueIndex #DomainName

## `description: str`
> [!info] Описание группы

## `members: dict[int, tuple[int, list[str]]]`
#TODO #TODO_MARK: возможно, монга офигеет от размера документа в коллекции и хранение списка участников станет точкой отказа БД
> [!info] Словарь участников типа `user_id : [custom_user_permissions, [group_role_id_one, group_role_id_two, ...]]`, где `group_role_id` - локальный ID групповой роли. Чтобы получить права доступа, задаваемые этой ролью, нужно найти объект этой group role в соответствующей коллекции по ID `group{group_id}_{group_role_local_id}`.
> Пример значения:
> ```json
> {
> 	1: [1, ["student"]]
> }
> ```
> Это кодирует группу с одним участником (`id1`), который имеет групповую роль `student` и персональные права `1`.
> #TODO Как будут работать персональные права? Мы будем их складывать, вычитать, xor'ить... с суммой прав по групповым ролям? #INFO Это хороший вопрос, на самом деле в такой системе можно только включать права, но не выключать. Я думаю нужно хранить custom_user_permissions не как двоичное, а как троичное число. То есть значение 0 в i бите будет значить что право определяется по наличию в ролях.1 - нет права, 2 - есть. Однако есть еще один вариант. Можно в переменной кастомных прав хранить окончательные права пользователя. То есть в интерфейсе управления правами изначально все тумблеры установлены в положение тукущих прав пользователя. А дальше когда что то изменяется, то изменяется custon_user_permission. Все ок, думаю я это смогу написать, и этот вариант лучше чем предыдущий
## `owner: int`
> [!info] ID cоздателя группы

